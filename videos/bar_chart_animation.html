<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bar chart animation</title>
    <link rel="stylesheet" href="css/common.css"/>
    <link rel="stylesheet" href="css/bar_horizon_styles.css"/>

    <script src="js/common.js"></script>
  </head>
    <body>
        <!-- for testing animation -->
        <canvas id="myCanvas" width="960" height="540"></canvas>  
        <!-- Full HD size -->
        <!-- <canvas id="myCanvas" width="1920" height="1080"></canvas>   -->

        <button id="recordBtn">Start Recording</button>
        <div id="divClock"></div>

        <script src="js/bar_chart_data.js"></script>
        <script src="js/draw_bars_horizontal.js"></script>

        <script>
          // Initial call
          // updateClock();
          // // Update every second
          // setInterval(updateClock, 1000);
          //
          let gapValue = get_gap_values();  //the length between max and min values
          print('gapValue', gapValue);

          const canvas = document.getElementById('myCanvas');
          const ctx = canvas.getContext('2d', { alpha: false });
          ctx.fillStyle = '#ffffff'; //white color
          var canvasW = canvas.width;
          var canvasH = canvas.height;

          var canvasScale = (canvasW / 960);
          var leftPositionBar = (canvasScale == 2)?250:160;

          ctx.fillRect(0, 0, canvasW, canvasH);
          //
          let scalingFactor = (canvasW - 250) / gapValue;
          //
          let colors = [
            "#e6194b","#3cb44b","#ffe119","#4363d8","#f58231",
            "#911eb4","#46f0f0","#f032e6","#bcf60c","#fabebe"
          ];
          let labels = ["Burkina Faso", "Congo", "Mexico", "Pakistan", "Palestine", "Russia", "Somalia", "Sudan", "Syria", "Ukraine"];
          
          //
          var data_list = transform_data(labels);
          print('data_list', data_list);
          
          var timer = null;
          var currentLoop = 0;  //simulate year index
          // Initial random data
          let data = data_list[currentLoop];  //Array.from({length: 10}, () => Math.floor(Math.random() * 100) + 10);

          // Target data (changes every 5s)
          let targetData = [...data];
          let animationStart = null;
          const duration = 12000; //animation time for 1 year (like 12 months)
          const delay_each_animation = 100;  //break time between an animation
          //init images
          let img_urls = ['https://cdn-icons-png.flaticon.com/512/555/555561.png', 'https://cdn-icons-png.flaticon.com/512/555/555421.png', 
            'https://cdn-icons-png.flaticon.com/128/14009/14009736.png', 'https://cdn-icons-png.flaticon.com/128/14009/14009752.png',
            'https://cdn-icons-png.flaticon.com/128/555/555509.png', 'https://cdn-icons-png.flaticon.com/128/555/555451.png',
            'https://cdn-icons-png.flaticon.com/128/555/555481.png', 'https://cdn-icons-png.flaticon.com/128/3373/3373307.png',
            'https://cdn-icons-png.flaticon.com/128/7941/7941803.png', 'https://cdn-icons-png.flaticon.com/128/3373/3373317.png'
          ]
          let img_list = [];
          var imgLoaded = false;
          for (var i=0; i<img_urls.length; i++){
            var img = new Image();
            img.crossOrigin = "anonymous";
            img.src = img_urls[i];
            img_list.push(img);
            img.onload = function(x) {
              imgLoaded = true;
            };
          }

          // Position cache for smooth reorder
          let positions = labels.map((_, i) => i);
          //somehow currentLoop is 2 at the beginning
          function draw(timestamp) {
            //
            ctx.clearRect(0, 0, canvasW, canvasH);
            // Always paint background
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvasW, canvasH);
            //draw year
            ctx.fillStyle = "#BA6352";
            ctx.font = (32 * canvasScale) + "px Arial";
            ctx.fillText(2016 + currentLoop - 3, canvasW / 2 - 20, canvasH - 20); //don't know why current Loop is latency

            if (!animationStart) animationStart = timestamp;
            const progress = Math.min((timestamp - animationStart) / duration, 1);

            // Interpolate values
            let currentData = data.map((d, i) => d + (targetData[i] - d) * progress);

            // Sort bars by currentData values
            let sortedIndices = currentData.map((v, i) => [v, i]).sort((a,b)=>b[0]-a[0]).map(x=>x[1]);

            // Smooth position transition
            let targetPositions = {};
            sortedIndices.forEach((id, idx) => targetPositions[id] = idx);

            positions = positions.map((p, i) => {
              return p + (targetPositions[i] - p) * 0.1; // easing movement
            });

            // Draw bars
            const barHeight = 30 * canvasScale;
            const gap = 15 * canvasScale;
            sortedIndices.forEach((id) => {
              //id is index of the item
              const value = currentData[id];
              const y = 50 + positions[id] * (barHeight + gap);
              const width = value * scalingFactor; // scaling factor

              ctx.fillStyle = colors[id];
              ctx.fillRect(leftPositionBar, y, width, barHeight);

              // Label
              ctx.fillStyle = "#BA6352";
              ctx.font = (16 * canvasScale) + "px Arial";
              ctx.fillText(labels[id], 15 + barHeight*1.3, y + barHeight/1.5);
              // Only draw image if it's loaded
              if (imgLoaded) {
                ctx.drawImage(img_list[id], 15, y, barHeight*1.2, barHeight);
              }
              // Value (animated counting)
              ctx.fillStyle = "#000";
              let displayVal = Math.floor(data[id] + (targetData[id] - data[id]) * progress);
              ctx.fillText(displayVal, leftPositionBar + 10 + width, y + barHeight/1.5);
            });
            // document.getElementById('divClock').textContent = 'Current loop: ' + currentLoop;
            if (progress < 1) {
              requestAnimationFrame(draw);
            } else {
              // After finish, lock new data
              data = [...targetData];
              positions = sortedIndices.map((id, idx)=>idx);

              // Trigger next change
              timer = setTimeout(() => {
                if (currentLoop >= data_list.length ){
                  clearInterval(timer);
                  document.getElementById('divClock').textContent = 'Stop';
                  return;
                }
                targetData = data_list[currentLoop++];
                animationStart = null;
                requestAnimationFrame(draw);
              }, delay_each_animation);
            }
          }

          // Start animation
          requestAnimationFrame(draw);
          //
          setTimeout(()=>{
            document.getElementById('divClock').textContent = 'Begin';
          }, duration * 2 - 2000);
          //
        </script>
        <script src="js/recording.js"></script>
    </body>
</html>