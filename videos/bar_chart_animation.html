<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bar chart animation</title>
    <link rel="stylesheet" href="css/common.css"/>
    <link rel="stylesheet" href="css/bar_horizon_styles.css"/>

    <script src="js/common.js"></script>
  </head>
    <body>
        <canvas id="myCanvas" width="960" height="540"></canvas>  <!-- for testing animation -->
        <!-- <canvas id="myCanvas" width="1920" height="1080"></canvas> -->  <!-- Full HD size -->

        <button id="recordBtn">Start Recording</button>
        <div id="divClock"></div>

        <script src="js/bar_chart_data.js"></script>
        <script src="js/draw_bars_horizontal.js"></script>

        <script>
          // Initial call
          updateClock();
          // Update every second
          setInterval(updateClock, 1000);
          let gapValue = get_gap_values();  //the length between max and min values
          print(gapValue);

          const canvas = document.getElementById('myCanvas');
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = '#fff'; //white color
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          //
          let scalingFactor = (canvas.width - 250) / gapValue;
          //
          let colors = [
            "#e6194b","#3cb44b","#ffe119","#4363d8","#f58231",
            "#911eb4","#46f0f0","#f032e6","#bcf60c","#fabebe"
          ];
          let labels = ["Burkina Faso", "Congo", "Mexico", "Pakistan", "Palestine", "Russia", "Somalia", "Sudan", "Syria", "Ukraine"];
          //
          var data_list = transform_data(labels);
          print(data_list)
          
          var timer = null;
          var currentLoop = 0;  //simulate year index
          // Initial random data
          let data = data_list[currentLoop];  //Array.from({length: 10}, () => Math.floor(Math.random() * 100) + 10);

          // Target data (changes every 5s)
          let targetData = [...data];
          let animationStart = null;
          const duration = 12000; //animation time for 1 year (like 12 months)
          const delay_each_animation = 100;  //break time between an animation

          // Position cache for smooth reorder
          let positions = labels.map((_, i) => i);

          function draw(timestamp) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!animationStart) animationStart = timestamp;
            const progress = Math.min((timestamp - animationStart) / duration, 1);

            // Interpolate values
            let currentData = data.map((d, i) => d + (targetData[i] - d) * progress);

            // Sort bars by currentData values
            let sortedIndices = currentData.map((v, i) => [v, i]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]);

            // Smooth position transition
            let targetPositions = {};
            sortedIndices.forEach((id, idx) => targetPositions[id] = idx);

            positions = positions.map((p, i) => {
              return p + (targetPositions[i] - p) * 0.1; // easing movement
            });

            // Draw bars
            const barHeight = 30;
            const gap = 15;
            sortedIndices.forEach((id) => {
              const value = currentData[id];
              const y = 50 + positions[id] * (barHeight + gap);
              const width = value * scalingFactor; // scaling factor

              ctx.fillStyle = colors[id];
              ctx.fillRect(150, y, width, barHeight);

              // Label
              ctx.fillStyle = "#000";
              ctx.font = "16px Arial";
              ctx.fillText(labels[id], 20, y + barHeight/1.5);

              // Value (animated counting)
              let displayVal = Math.floor(data[id] + (targetData[id] - data[id]) * progress);
              ctx.fillText(displayVal, 160 + width, y + barHeight/1.5);
            });

            if (progress < 1) {
              requestAnimationFrame(draw);
            } else {
              // After finish, lock new data
              data = [...targetData];
              positions = sortedIndices.map((id, idx)=>idx);

              // Trigger next change
              timer = setTimeout(() => {
                if (currentLoop >= data_list.length ){
                  clearInterval(timer);
                  return;
                }
                targetData = data_list[currentLoop++];
                animationStart = null;
                requestAnimationFrame(draw);
              }, delay_each_animation);
            }
          }

          // Start animation
          requestAnimationFrame(draw);

        </script>
        <script src="js/recording.js"></script>
    </body>
</html>