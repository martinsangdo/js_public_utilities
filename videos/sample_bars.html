<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Animated Bar Chart</title>
<style>
  body {
    background: #f9f9f9;
    font-family: Arial, sans-serif;
    display: flex;
    justify-content: center;
    margin-top: 30px;
  }
  canvas {
    border: 1px solid #ccc;
    background: #fff;
  }
</style>
</head>
<body>
<canvas id="barChart" width="800" height="500"></canvas>

<div id="divClock"></div>

<script>
const canvas = document.getElementById("barChart");
const ctx = canvas.getContext("2d");

let colors = [
  "#e6194b","#3cb44b","#ffe119","#4363d8","#f58231",
  "#911eb4","#46f0f0","#f032e6","#bcf60c","#fabebe"
];
let labels = ["A","B","C","D","E","F","G","H","I","J"];

// Initial random data
let data = Array.from({length: 10}, () => Math.floor(Math.random() * 100) + 10);

// Target data (changes every 5s)
let targetData = [...data];
let animationStart = null;
const duration = 10000; //animation time
const delay_each_animation = 2000;  //break time between animation

// Position cache for smooth reorder
let positions = labels.map((_, i) => i);

function draw(timestamp) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (!animationStart) animationStart = timestamp;
  const progress = Math.min((timestamp - animationStart) / duration, 1);

  // Interpolate values
  let currentData = data.map((d, i) => d + (targetData[i] - d) * progress);

  // Sort bars by currentData values
  let sortedIndices = currentData.map((v, i) => [v, i]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]);

  // Smooth position transition
  let targetPositions = {};
  sortedIndices.forEach((id, idx) => targetPositions[id] = idx);

  positions = positions.map((p, i) => {
    return p + (targetPositions[i] - p) * 0.1; // easing movement
  });

  // Draw bars
  const barHeight = 30;
  const gap = 15;
  sortedIndices.forEach((id) => {
    const value = currentData[id];
    const y = 50 + positions[id] * (barHeight + gap);
    const width = value * 5; // scaling factor

    ctx.fillStyle = colors[id];
    ctx.fillRect(150, y, width, barHeight);

    // Label
    ctx.fillStyle = "#000";
    ctx.font = "16px Arial";
    ctx.fillText(labels[id], 100, y + barHeight/1.5);

    // Value (animated counting)
    let displayVal = Math.floor(data[id] + (targetData[id] - data[id]) * progress);
    ctx.fillText(displayVal, 160 + width, y + barHeight/1.5);
  });

  if (progress < 1) {
    requestAnimationFrame(draw);
  } else {
    // After finish, lock new data
    data = [...targetData];
    positions = sortedIndices.map((id, idx)=>idx);

    // Trigger next change
    setTimeout(() => {
      targetData = Array.from({length: 10}, () => Math.floor(Math.random() * 100) + 10);
      animationStart = null;
      requestAnimationFrame(draw);
    }, delay_each_animation);
  }
}

// Start animation
requestAnimationFrame(draw);

function updateClock() {
  const now = new Date();
  const minutes = String(now.getMinutes()).padStart(2, '0');
  const seconds = String(now.getSeconds()).padStart(2, '0');
  document.getElementById('divClock').textContent = `${minutes}:${seconds}`;
}

// Initial call
updateClock();
// Update every second
setInterval(updateClock, 1000);

</script>
</body>
</html>
